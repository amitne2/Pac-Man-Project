diff a/Pacman/Ghost.cpp b/Pacman/Ghost.cpp	(rejected hunks)
@@ -1,10 +1,13 @@
 #include "Ghost.h"
+#include "ThePacmanGame.h"
+#include <random>
 
 //Constructor ghost
 Ghost::Ghost(int _y, int _x, int _direction, char _gameLevel, int _countSteps) : Game_Object(_x, _y, _direction) 
 {
 	gameLevel = _gameLevel;
 	countSteps = _countSteps;
+	levelBIndication = false;
 }
 
 //This function ramdon a number between 1-4 for direction
@@ -12,20 +15,10 @@
 //Checks if the ghost is on pacman position (strike in the game) - update the relevant variables
 void Ghost::move(const Point& pac)
 {
-	//int dir;
-	//dir = rand() % 3; //random a number 
 	setDirection(pac);
 	position[1] = position[0]; 
 	position[0].move(direction, NOT_PACMAN);
 
-	while (theGame->isWall(position[1].next(direction, NOT_PACMAN), NOT_PACMAN)) //Checks if the next move position is a wall
-	{
-		position[0] = position[1];
-		direction = rand() % 3;
-		position[0].move(direction, NOT_PACMAN);
-	}
-	theGame->setBoardBeforeObjectMoves(position[1]); //Update board before strike
-
 	if (theGame->checkIfTheSamePosition(pac, position[0])) //Checks if the next move is on pacman position
 	{
 		if(theGame->getColored()) //Set color
@@ -36,7 +29,7 @@
 		theGame->ghostAtePacman();
 	}
 
-	else
+	else if(!theGame->isWall(position[1].next(direction, NOT_PACMAN), NOT_PACMAN))
 	{
 		if(theGame->getColored()) //Set color
 			setTextColor(LIGHTMAGENTA);
@@ -44,24 +37,36 @@
 		position[1] = position[0];
 		setTextColor(WHITE);
 	}
+	//theGame->setBoardBeforeObjectMoves(position[1]); 
 }
 
 void Ghost::setDirection(const Point& pac)
 {
+	int randRes;
 	switch (gameLevel)
 	{
 	case 'a': //BEST level
 		chasePacman(pac);
 		break;
 	case 'b': //GOOD level
-		if (countSteps == MAX_MOVES)
-			direction = rand() % 3;
-		else
+		
+		if (!levelBIndication) // if levelBIndication is true, it means the ghost is in the 5 steps after the rand direction, stays in the same one
 		{
-			if (countSteps == MAX_MOVES + 5)
-				countSteps = 0;
-			chasePacman(pac);
+			randRes = rand() % 20 < 1 ? 1 : 0; //random 1 in probability of 1/20
+			if (!randRes) 
+			{
+				direction = rand() % 3; //random a new direction
+				countSteps = 0; //set counter to count 5 steps of the same direction
+				levelBIndication = true; //set true to prevent ghost from changing its direction for 5 steps
+			}
+			else
+				chasePacman(pac); //smart ghost
 		}
+		else if(countSteps == 5) //ghost was on the same direction for 5 steps until now, now becomes a smart ghost
+		{
+				chasePacman(pac); //smart ghost
+				levelBIndication = false; //get out of the 5-same-direction-steps state 
+		}	
 		break;
 	case 'c': //NOVICE level
 		if (countSteps == MAX_MOVES)
